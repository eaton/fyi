---
id: thread.t1374201198341931015
type: SocialMediaThread
title: Engaging with domain complexity
url: 'https://www.x.com/eaton/status/1374201198341931015'
isPartOf: blog.@eaton
hasPart:
  - 'https://www.x.com/eaton/status/1374201198341931015'
  - 'https://www.x.com/eaton/status/1374202905583042566'
  - 'https://www.x.com/eaton/status/1374203576025812995'
  - 'https://www.x.com/eaton/status/1374204041576714241'
  - 'https://www.x.com/eaton/status/1374204342874615812'
date: 2021-03-23T03:27:51.000Z
dates:
  start: 2021-03-23T03:27:51.000Z
  end: 2021-03-23T03:40:21.000Z
favorites: 38
handle: eaton
retweets: 3
---
https://twitter.com/peterseibel/status/1374190131381297154

They always start with "we can make this complicated task accessible" and end with "It's just as complex, but with a lot more clicking"

The interesting thing is that visualization of complex language constructs is a really useful and important part of many advanced IDEs. Generating query diagrams from SQL EXPLAIN, class maps from metadata, etc.

Back in 2013 or so @mbakeranalecta wrote about one facet of the disconnect â€” WYSIWYG tools can be powerful, but they depend on what "what" you're using them to expose. [https://everypageispageone.com/2013/12/05/changing-the-what-in-wysiwyg](https://everypageispageone.com/2013/12/05/changing-the-what-in-wysiwyg)

A lot of "visual code-builders" either expose components large enough that you're really just wiring multiple programs together, OR they expose individual language constructs visually. Which can be useful for learning but horrible for actual coding.

As Baker says in his post, there's nothing preventing a 'WYSIWYG' tool from exposing structural metadata instead of visual formatting, but it's not how we often *think* about the utility of GUI layers on top of code.
